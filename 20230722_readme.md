package.json : 프로젝트의 전체적인 정책 파일이라고 생각.
npm start : 서버 시작
npm run build : build라는 폴더명이 생기고 배포판이 안에 생성됨.
배포 ! : https://app.netlify.com/drop 
-> build 파일 폴더 드랍하면 서버 라이브화 됨 ㅎ (한시간 제한)

---


리액트는 사용자정의태그를 만드는 기술인다.
사용자정의 태그를 컴포넌트라고 부른다.


props는 입력값이다.
props예시 
```javascript
title="불면증 카운터" initValue="10"
```

{} js의 데이터타입으로 인식
"" 문자열로 인식
함수의 리턴값에서 {}를 쓰면 변수로 간주

---
리액트의 코드는 js가 아님. 유사 js. 이름하야 'jsx'
jsx는 js+태그를 쉽게 코드에 포함시킬 수 있도록 고안된 js의 확장된 언어이다.

컴포넌트 밖에서 컴포넌트 사용자가 props를 맘대로 바꿀 수 없음.
=props는 외부에서 내부로 주입되는 상태
=state는 내부적으로 사용하는 상태

이벤트의 값은 함수이다. ex) onClick={up}
props의 값은 read only이다. 
그래서 state를 활용해서 바꿔야 한다. state의 값은 쓰기 가능.

(변수를 useState 사용하여 'state'화 할 수 있고)
state는 배열 형태이다
상태의 첫번째 원소는 값이다(수정 불가). 두번째는 상태의 값을 바꿀 때 호출하는 '함수'이다(수정 가능). 
즉 첫번째는 읽을 때 쓰고, 변경할 때는 두번째로 쓰면 됨. 
두번째는 수정할 때 호출되고, 파라미터가 변경되었을 때만 컴포넌트가 다시 실행된다.
->props, satate가 바뀌면 컴포넌트가 다시 랜더링. 그래서 react가 성능이 좋은 것. 바뀔때만 다시 렌더링 되기에

-- 

sideeffect는 useeffect에 격리한다. 
장점:
- sideeffect를 쉽게 파악할 수 있다. 
- 테스팅할 때 유리
- sideeffect 실행 타이밍을 제어할 수 있다. 이를 제어할 때두 번째 파라메터가 없으면 컴포넌트와 함께 실행된다. 빈 배열이면 딱 한번 실행된다. 값이 있으면 그 값이 변경 되었을 때 실행된다. 

함수가 정의 될 때 함수 내에서 사용되는 변수는 함수 내에 봉인된다. => closure라고 한다. 

set함수의 입력값은 값이거나 함수이다. 함수의 파라메터는 신선한 상태의 값이다. return 값이 새로운 상태가 된다. 

useeffect의 리턴값은 정리할 때 사용한다. unmount. 재실행될 때 자동으로 호출된다. 